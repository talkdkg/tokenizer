h2. Business Domain

OWNER - Channel Owner; uses web UI to chat

USER - Channel Subscriber; uses mobile device UI to chat

SENDER - each Message has a Sender, it can be either Owner or User; each Message is assigned to a Channel having an Owner; each Message has assigned to a Chat Session; so that we also implicitly have "message receiver".

CHANNEL - Owner can have multiple Channels; each Channel can have multiple active/ended Chat Sessions; and each Chat Session is point-to-point chat between Owner and User

CHAT_SESSION - User (Channel Subscriber) can initiate Chat with Channel Owner

MESSAGE - message...


h2. Chat Sessions Use Cases

- Create a chat session
- Close a chat session
- Delete a chat session
- Get a list of all active chat sessions for a channel
- Get the number of active chat sessions for a channel
- Get the latest active chat session for a channel
- Get the oldest active chat session for a channel


h3. Chat Sessions Schema

{code}
/* active chat sessions, recently closed chat sessions */
create column family CHANNEL_CHAT_SESSIONS 
    
    /* RowKey: channel_id */
    WITH key_validation_class = UTF8Type
    
    /* session_id: TimeUUIDType uses session_creation_time for the index */
    AND comparator = TimeUUIDType
    
    /* optional: session_end_time */
    AND default_validation_class = DateType;


/* archive of closed chat sessions */
create column family CHANNEL_CHAT_SESSIONS_ARCHIVE

    /* RowKey: channel_id */
    WITH key_validation_class = UTF8Type

     /* session_id: TimeUUIDType uses session_creation_time for the index */
    AND comparator = TimeUUIDType
    
    /* mandatory: session_end_time */
    AND default_validation_class = DateType;
{code}

Rationale:
- we can not have too wide rows
- we have a use case "find all active sessions"
- we shouldn't update column name: if will trigger reindexing of possibly wide row

CHANNEL_CHAT_SESSIONS 
- contains all active sessions + recently closed sessions
- "most frequently" read
- "moderate' insert/update/delete

CHANNEL_CHAT_SESSIONS_ARCHIVE 
- contains closed chat sessions; possibly wide rows, thousands sessions in a row
- "least frequently" read
- "moderate" insert
- "almost never" delete
- "never" update


h3. Chat Sessions Use Cases: Logical Implementation
 
h4. Create a chat session

Input parameters: 
- channel id
- session creation time

Processing:   
1. Generate UUID Type 1 using provided time
2. Insert into CHANNEL_CHAT_SESSIONS column with key=UUID and value=null

Return: Session UUID

h4. Close a chat session

We need to update two column families in a non-transactional datastore. To enforce data consistency, we are using "value" to temporary store session end time.

Processing:
1. Update CHANNEL_CHAT_SESSIONS set VALUE := session end time
2. Insert into CHANNEL_CHAT_SESSIONS_ARCHIVE <name:SessionUUID, value:SessionEndTime>
3. Delete from CHANNEL_CHAT_SESSIONS <name:SessionUUID, value:SessionEndTime>

This can further split into syncrhonous step 1, and asynchronous step 2 and 3 ("future task" etc); it will be initially implemented as a single synchronous batch.
Note, our "Read Active Session" use case will double check "value" field and perform 2 & 3 if necessary. 


h4. Delete a chat session

Processing 
- verify non-existence in CHANNEL_CHAT_SESSIONS
- delete a cell from CHANNEL_CHAT_SESSIONS_ARCHIVE
- delete from Messages Archive (we need background process verifying that Messages Archieve are consistent with Sessions Archive)  


h4. Get a list of all active chat sessions for a channel

- Read a record from CHANNEL_CHAT_SESSION with specified RowKey = "MyChannelID"
- if value (session end time) of any cell is not "null" verify CHANNEL_CHAT_SESSION_ARCHIEVE and delete from CHANNEL_CHAT_SESSION
- return filtered list 


h4. Get the number of active chat sessions for a channel

Same as previous

h4. Get the latest active chat session for a channel

TimeUUIDType uses timestamp for indexing


h4. Get the oldest active chat session for a channel

Same as previous

h2. Chat Messages Use Cases

- Add a chat message into a chat session
- Mark a chat message to be delivered and read
- Get all chat messages for a chat session, the chat messages are in the order they are created
- Get the chat messages of chat session from a sender that has sequence number between 5 to 10, the chat messages must be in the order they are created
- Get the last sequence number of a sender for a chat session

h3. Chat Messages Schema

{code}
/* Chat Session Messages */
create column family CHANNEL_CHAT_SESSION_MESSAGES

    /*chat_session_uuid*/
    WITH key_validation_class = TimeUUIDType 
    
    /* CompositeType: creation_timestamp, sender_sequence_number, sender_id */
    AND comparator = 'CompositeType(TimeUUIDType, IntegerType, UTF8Type)'
    
    /* message_text */
    AND default_validation_class = UTF8Type;

/* Secondary Index: Sender ID, Sequence Number */
create column family CHANNEL_CHAT_SESSION_MESSAGES_SENDER_IDX

    /*chat_session_uuid*/
    WITH key_validation_class = TimeUUIDType 
    
    /* CompositeType: sender_id, sequence_number, creation_timestamp */
    AND comparator = 'CompositeType(UTF8Type, IntegerType, TimeUUIDType)'
    
    /* message_event: OFFLINE, DELIVERED, DISPLAYED */
    AND default_validation_class = IntegerType;

{code}


h3. Netflix Astyanax Java Samples

h4. Start Context
{code}
        context = new AstyanaxContext.Builder().forCluster("Test Cluster").forKeyspace("msdp_chat_demo")
                .withAstyanaxConfiguration(new AstyanaxConfigurationImpl().setDiscoveryType(NodeDiscoveryType.NONE))
                .withConnectionPoolConfiguration(new ConnectionPoolConfigurationImpl("MyConnectionPool").setPort(9160).setMaxConnsPerHost(1).setSeeds("127.0.0.1:9160"))
                .withConnectionPoolMonitor(new CountingConnectionPoolMonitor()).buildKeyspace(ThriftFamilyFactory.getInstance());

        context.start();
{code}


h4. Create Column Family CHANNEL_CHAT_SESSION_MESSAGES     
        
{code}        
        keyspace = context.getEntity();

        CF_SESSION_MESSAGES = new ColumnFamily<UUID, Composite>("CHANNEL_CHAT_SESSION_MESSAGES", TimeUUIDSerializer.get(), CompositeSerializer.get());

        keyspace.createColumnFamily(CF_SESSION_MESSAGES, ImmutableMap.<String, Object> builder()

        // chat_session_id:
                .put("key_validation_class", "TimeUUIDType")

                // https://github.com/Netflix/astyanax/issues/80
                // do not use Int32Type...
                // creation_timestamp, sequence_number, sender_id:
                .put("comparator_type", "CompositeType(DateType, IntegerType, UTF8Type)")

                // message_text:
                .put("default_validation_class", "UTF8Type")

                .build());
{code}


h4. Insert Message

{code}
    public static void insert(final Message message) throws ConnectionException {
        Composite cc = new Composite(message.getCreationDate(), message.getSequenceNumber(), message.getSenderId());

        keyspace.prepareColumnMutation(CF_SESSION_MESSAGES, message.getChatSessionUUID(), cc) //
                .putValue(message.getText(), null).execute();
    }
{code}

h4. Read All Messages for a Session

{code}
    public static void printSessionMessages(final ChatSession chatSession) throws ConnectionException {

        OperationResult<ColumnList<Composite>> result = keyspace.prepareQuery(CF_SESSION_MESSAGES) //
                .getKey(chatSession.getChatSessionUUID()) //
                .execute();
        ColumnList<Composite> columns = result.getResult();

        for (Column<Composite> column : columns) {

            Composite name = column.getName();

            Message message = new Message();

            Date creationDate = DateSerializer.get().fromByteBuffer((java.nio.ByteBuffer) name.get(0));
            message.setCreationDate(creationDate);

            Integer sequenceNumber = BigIntegerSerializer.get().fromByteBuffer((java.nio.ByteBuffer) name.get(1)).intValue();
            message.setSequenceNumber(sequenceNumber);

            String senderId = StringSerializer.get().fromByteBuffer((java.nio.ByteBuffer) name.get(2));
            message.setSenderId(senderId);

            String text = column.getStringValue();

            message.setText(text);

            System.out.println(message);

        }
{code}
                